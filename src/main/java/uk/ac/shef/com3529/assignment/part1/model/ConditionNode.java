package uk.ac.shef.com3529.assignment.part1.model;

import uk.ac.shef.com3529.assignment.part1.model.enums.ComparisonRelation;

public class ConditionNode extends BinaryRelatedNode<ComparisonRelation> {
    public ConditionNode(SyntaxNode leftNode, ComparisonRelation relation, SyntaxNode rightNode) {
        super(leftNode, relation, rightNode);
    }

    @Override
    public boolean getResult() {
        if (resultOverrode) {
            return result;
        }

        // It is assumed that there will only be 4 cases of the combination of the type of rightNode & leftNode since the
        // nodes are generated by the imaginary parser.

        // case 1: both node are BinaryRelatedNode. In this case, the only possible relation is either equals or not equals
        if (leftNode instanceof BinaryRelatedNode<?> &&
                rightNode instanceof BinaryRelatedNode<?>) {

            boolean leftNodeResult = ((BinaryRelatedNode<?>) leftNode).getResult();
            boolean rightNodeResult = ((BinaryRelatedNode<?>) rightNode).getResult();

            if (relation == ComparisonRelation.EqualsEquals) {
                return leftNodeResult == rightNodeResult;
            } else {
                return leftNodeResult != rightNodeResult;
            }
        }

        // both node can only be ArithmeticNode or VariableNode. The rest scenario are:
        // case 2: both are ArithmeticNode
        // case 3: both are VariableNode
        // case 4: one of them is ArithmeticNode & one is VariableNode

        double leftNodeVal;
        double rightNodeVal;

        if (leftNode instanceof ArithmeticNode) {
            leftNodeVal = ((ArithmeticNode) leftNode).getResult();
        } else {
            // have to cast the number value to a concrete number type. have chosen double here as it can represent most
            // of the number value in Java
            leftNodeVal = ((VariableNode<?>) leftNode).getValue().doubleValue();
        }

        if (rightNode instanceof ArithmeticNode) {
            rightNodeVal = ((ArithmeticNode) rightNode).getResult();
        } else {
            rightNodeVal = ((VariableNode<?>) rightNode).getValue().doubleValue();
        }

        switch (relation) {
            case EqualsEquals:
                return leftNodeVal == rightNodeVal;
            case NotEquals:
                return leftNodeVal != rightNodeVal;
            case LargerThan:
                return leftNodeVal > rightNodeVal;
            case LargerOrEqualsTo:
                return leftNodeVal >= rightNodeVal;
            case SmallerThan:
                return leftNodeVal < rightNodeVal;
            case SmallerOrEqualsTo:
                return leftNodeVal <= rightNodeVal;
        }
        throw new IllegalStateException("there is an error from the ComparisonRelation");
    }
}
