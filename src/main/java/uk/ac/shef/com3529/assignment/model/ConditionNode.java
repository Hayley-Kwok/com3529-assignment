package uk.ac.shef.com3529.assignment.model;

import uk.ac.shef.com3529.assignment.model.enums.ComparisonRelation;

import java.util.Objects;

public class ConditionNode extends BinaryRelatedNode<ComparisonRelation> {
    private boolean result;
    private boolean resultOverrode;

    public ConditionNode(SyntaxNode leftNode, ComparisonRelation relation, SyntaxNode rightNode) {
        super(leftNode, relation, rightNode);
    }

    public ConditionNode(SyntaxNode leftNode, ComparisonRelation relation, SyntaxNode rightNode, boolean negation) {
        super(leftNode, relation, rightNode, negation);
    }

    public boolean getResultOverrode() {
        return resultOverrode;
    }

    public void resetResultOverrode() {
        this.resultOverrode = false;
        this.result = false;
    }

    public void setResult(boolean result) {
        this.resultOverrode = true;
        this.result = result;
    }

    @Override
    public boolean getResult() {
        if (resultOverrode) {
            return result;
        }

        return flipResult(getNotNegatedResult());
    }

    private boolean getNotNegatedResult() {
        // It is assumed that there will only be 4 cases of the combination of the type of rightNode & leftNode since the
        // nodes are generated by the imaginary parser.

        // case 1: both node are BinaryRelatedNode. In this case, the only possible relation is either equals or not equals
        if (leftNode instanceof BinaryRelatedNode<?> &&
                rightNode instanceof BinaryRelatedNode<?>) {

            boolean leftNodeResult = ((BinaryRelatedNode<?>) leftNode).getResult();
            boolean rightNodeResult = ((BinaryRelatedNode<?>) rightNode).getResult();

            if (relation == ComparisonRelation.EqualsEquals) {
                return leftNodeResult == rightNodeResult;
            } else {
                return leftNodeResult != rightNodeResult;
            }
        }

        // both node can only be ArithmeticNode or VariableNode. The rest scenario are:
        // case 2: both are ArithmeticNode
        // case 3: both are VariableNode
        // case 4: one of them is ArithmeticNode & one is VariableNode

        double leftNodeVal;
        double rightNodeVal;

        if (leftNode instanceof ArithmeticNode) {
            leftNodeVal = ((ArithmeticNode) leftNode).getResult();
        } else {
            // have to cast the number value to a concrete number type. have chosen double here as it can represent most
            // of the number value in Java
            leftNodeVal = ((VariableNode<?>) leftNode).getValue().doubleValue();
        }

        if (rightNode instanceof ArithmeticNode) {
            rightNodeVal = ((ArithmeticNode) rightNode).getResult();
        } else {
            rightNodeVal = ((VariableNode<?>) rightNode).getValue().doubleValue();
        }

        switch (relation) {
            case EqualsEquals:
                return leftNodeVal == rightNodeVal;
            case NotEquals:
                return leftNodeVal != rightNodeVal;
            case LargerThan:
                return leftNodeVal > rightNodeVal;
            case LargerOrEqualsTo:
                return leftNodeVal >= rightNodeVal;
            case SmallerThan:
                return leftNodeVal < rightNodeVal;
            case SmallerOrEqualsTo:
                return leftNodeVal <= rightNodeVal;
        }
        throw new IllegalStateException("there is an error from the ComparisonRelation");
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o.getClass() != this.getClass()) return false;
        ConditionNode that = (ConditionNode) o;
        return result == that.result &&
                resultOverrode == that.resultOverrode &&
                super.equals(that);
    }

    @Override
    public int hashCode() {
        return Objects.hash(relation, leftNode, rightNode, negated, resultOverrode, result);
    }
}
